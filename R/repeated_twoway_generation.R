#' Both regular and internal function.
#' As regular function takes input generated by the 'calculate_mean_matrix' function and iteratively simulates repeated measures two-way factorial experiments.
#' Data are sampled from a normal distribution.
#'
#' As internal function runs with a single iteration inside 'graph_twoway_assumptions', which in itself is inside  'calculate_mean_matrix' to generate data for the cell mean and standard deviation plot.
#'
#' @param group_size Integer - sample size for each cell
#' @param matrices_obj List - Output generated by 'calculate_mean_matrix' that include cell mean and covariance matrices
#' @param nsims Integer - Number of iterations
#'
#' @return Dataframe with simulated outcome values, factor level labels and iteration number.
#'
#' ## Repeated measures design, suppose subjects from 4 independent treatment groups measured at 5 different timepoints.
#'
#' refmean <- 1
#' treatgroups <- 4
#' timepoints <- 5
#' treateff <- 1.5
#' timeeff <- 0.85
#' rho <- 0.8
#' withinf <- "fB"
#'
#' effects_treat_time <- calculate_mean_matrix(refmean = refmean, fAeffect = treateff, fBeffect = timeeff, nlfA = treatgroups,  nlfB = timepoints,
#' rho = rho, withinf = withinf, label_list = list(treatment=letters[1:treatgroups], time=1:timepoints))
#'
#' ## Inspect plot to check if matrices correspond to design
#' n <- 20
#' repeatedmeasures_experiment <- twoway_simulation_correlated(group_size = n, matrices_obj = effects_treat_time)
#' head(repeatedmeasures_experiment, 10)
#'
#' @export
twoway_simulation_correlated <- function(group_size, matrices_obj, nsims=500)
{
  if(!all(sapply(matrices_obj[-1], is.matrix)))
    {
    matrices_obj <- matrices_obj$matrices_obj
    }
  label_list <- dimnames(matrices_obj$mean.mat)
  factor_levels <- dim(matrices_obj$mean.mat)
  mean_matrix <- as.vector(t(matrices_obj$mean.mat))
  if(length(group_size)>1 | as.integer(group_size)!=group_size)
  {
    stop("group_size must be a single integer")
  }
  sigmatrix <- matrices_obj$sigmat
  withinf <- matrices_obj$within.factor

  if(withinf=="both")
  {
    subject <- rep(1:group_size, prod(factor_levels))
  }
  else if (withinf=="fA")
  {
    subject <- rep(1:(group_size*factor_levels[2]), factor_levels[1])
  }
  else if (withinf=="fB")
  {
    subject <- rep(1:(group_size*factor_levels[1]), each=factor_levels[2])
  }
  fdata <- as.data.frame(MASS::mvrnorm(group_size, mean_matrix, sigmatrix))
  fdata$subject <- 1:group_size
  fdata <- reshape2::melt(fdata, id.vars = "subject", variable.name = "cond",
                          value.name = "y")
  fdata$subject <- subject
  for (j in 1:2)
  {
    fdata <- cbind(fdata,
                   as.factor(unlist(
                     rep(as.list(paste(names(label_list)[j], label_list[[j]], sep = "_")),
                         each = group_size * prod(factor_levels)/prod(factor_levels[1:j]),
                         times = prod(factor_levels)/prod(factor_levels[j:2])))))
  }
  names(fdata)[4:5] <- names(label_list)

  if(length(group_size)==1)
  {
    if(distribution=="normal")
    {
      y <- suppressMessages(replicate(nsims, reshape2::melt(as.data.frame(MASS::mvrnorm(n = group_size, mu = mean_matrix, Sigma = sigmatrix)))$value))
    }
  }
  sim <- lapply(seq(nsims),
                function(x)
                {
                  fdata$y <- y[,x]
                  fdata$iteration <- x
                  fdata
                })
  do.call(rbind, sim)
}
