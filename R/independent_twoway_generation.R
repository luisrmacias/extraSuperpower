#' Simulate independent measurements in a two-way factorial design
#'
#' Both regular and internal function.
#' As regular function takes input generated by the 'calculate_mean_matrix' function and iteratively simulates independent measures two-way factorial experiments.
#' Outcome may be normally distributed, truncated normally distributed or skewed.
#'
#' As internal function runs with a single iteration inside 'graph_twoway_assumptions', which in itself is inside  'calculate_mean_matrix' to generate data for the cell mean and standard deviation plot.
#'
#' @param group_size Integer - sample size for each cell
#' @param matrices_obj List - Output generated by 'calculate_mean_matrix' that include cell mean and standard deviation matrices
#' @param distribution Character - Type of distribution to simulate. Possible values are 'normal', 'truncated' or 'skewed'.
#' @param skewness Numeric - Momentum of distribution skewness
#' @param inferior_limit Numeric - Value of the lower bound for the truncated distribution, defaults to '-Inf'
#' @param superior_limit Numeric - Value of the upper bound for the truncated distribution, defaults to 'Inf'
#' @param nsims Integer - Number of iterations
#'
#' @return Dataframe with simulated outcome values, factor level labels, iteration number and sample size.
#'
#' @examples
#' refmean <- 1
#' treatgroups <- 4
#' timepoints <- 5
#' treateff <- 1.5
#' timeeff <- 0.85
#' ## Independent design
#' effects_treat_time <- calculate_mean_matrix(refmean = refmean, fAeffect = treateff, fBeffect = timeeff, nlfA = treatgroups, nlfB = timepoints, label_list = list(treatment=letters[1:treatgroups], time=1:timepoints))
#' ## Inspect plot to check if matrices correspond to design
#' n <- 20
#' independent_experiment <- twoway_simulation_independent(group_size = n, matrices_obj = effects_treat_time)
#' head(independent_experiment, 10)
#'
#' @export
twoway_simulation_independent <- function(group_size, matrices_obj, distribution="normal", skewness=1, inferior_limit=-Inf, superior_limit=Inf, balanced=TRUE, nsims=500)
{
  if(!all(sapply(matrices_obj, is.matrix)))
  {
    matrices_obj <- matrices_obj$matrices_obj
  }
  label_list <- dimnames(matrices_obj$mean.mat)
  factor_levels <- dim(matrices_obj$mean.mat)
  mean_matrix <- as.vector(t(matrices_obj$mean.mat))
  if(length(group_size)>1 | as.integer(group_size)!=group_size)
  {
    stop("Number of elements of mean matrix must be a multiple of group size elements.")
  }
  sd_matrix <- as.vector(t(matrices_obj$sd.mat))
  if(balanced & length(group_size)==1)
  {
    fdata <- as.data.frame(mapply(rnorm, group_size, mean_matrix, sd_matrix))
    fdata$subject <- 1:group_size
    fdata <- reshape2::melt(fdata, id.vars = "subject", variable.name = "cond",
                            value.name = "y")
    for (j in 1:2)
    {
      assigned_factor_levels <- rep(as.list(paste(names(label_list)[j], label_list[[j]], sep = "_")),
                                    each = group_size * prod(factor_levels)/prod(factor_levels[1:j]),
                                    times = prod(factor_levels)/prod(factor_levels[j:2]))
      assigned_factor_levels <- unlist(assigned_factor_levels)
      assigned_factor_levels <- factor(assigned_factor_levels, levels = unique(assigned_factor_levels))
      fdata <- cbind(fdata, assigned_factor_levels)
    }
    names(fdata)[4:5] <- names(label_list)

    if(distribution=="normal")
    {
      y <- suppressMessages(replicate(nsims, reshape2::melt(mapply(rnorm, group_size,
                                                                   mean_matrix, sd_matrix))$value))
    } else if (distribution=="skewed")
    {
      y <- suppressMessages(replicate(nsims, reshape2::melt(mapply(fGarch::rsnorm, group_size,
                                                                   mean_matrix, sd_matrix, skewness))$value))
    } else if (distribution=="truncated.normal")
    {
      y <- suppressMessages(replicate(nsims, reshape2::melt(mapply(truncnorm::rtruncnorm, group_size, a=inferior_limit, b=superior_limit,
                                                                   mean_matrix))$value))
    }
  } else if (!balanced & length(group_size)==1)
  {
    stop("Are you sure you want to set balanced to false?")
  } else if (!balanced & length(group_size)>1)
  {
    if(distribution=="normal")
    {
      y <- suppressMessages(replicate(nsims, reshape2::melt(mapply(rnorm, group_size, mean_matrix, sd_matrix))$value))
    } else if (distribution=="skewed")
    {
      y <- mapply(fGarch::rsnorm, group_size, mean_matrix, sd_matrix, skewness)
    }

  } else if (balanced & length(group_size)>1)
  {
    stop("If you wish a balanced design a single integer is required as first argument.")
  }
  sim <- lapply(seq(nsims),
                function(x)
                {
                  fdata$y <- y[,x]
                  fdata$iteration <- x
                  fdata$subject <- factor(1:nrow(fdata))
                  fdata
                })
  sim <- do.call(rbind, sim)
  sim$n <- group_size
  sim
}
