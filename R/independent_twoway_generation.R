#' Both regular and internal function.
#' As regular function takes input generated by the 'calculate_mean_matrix' function and iteratively simulates independent measures two-way factorial experiments.
#' Outcome may be normally distributed or skewed.
#'
#' As internal function runs with a single iteration inside 'graph_twoway_assumptions', which in itself is inside  'calculate_mean_matrix' to generate data for the cell mean and standard deviation plot.
#'
#' @param group_size Integer - sample size for each cell
#' @param matrices_obj List - Output generated by 'calculate_mean_matrix' that include cell mean and standard deviation matrices
#' @param distribution Character - Type of distribution to simulate. Possible values are 'normal' or 'skewed'.
#' @param skewness Numeric - Momentum of distribution skewness
#' @param nsims Integer - Number of iterations
#'
#' @return Dataframe with simulated outcome values, factor level labels and iteration number.
#'
#' @examples
#' refmean <- 1
#' treatgroups <- 4
#' timepoints <- 5
#' treateff <- 1.5
#' timeeff <- 0.85
#' ## Independent design
#' effects_treat_time <- calculate_mean_matrix(refmean = refmean, fAeffect = treateff, fBeffect = timeeff, nlfA = treatgroups, nlfB = timepoints, label_list = list(treatment=letters[1:treatgroups], time=1:timepoints))
#' ## Inspect plot to check if matrices correspond to design
#' n <- 20
#' independent_experiment <- twoway_simulation_independent(group_size = n, matrices_obj = effects_treat_time)
#' head(independent_experiment, 10)
#'
#' @export
twoway_simulation_independent <- function(group_size, matrices_obj, distribution="normal", skewness=1, nsims=500)
{
  if(!all(sapply(matrices_obj, is.matrix)))
  {
    matrices_obj <- matrices_obj$matrices_obj
  }
  label_list <- dimnames(matrices_obj$mean.mat)
  factor_levels <- dim(matrices_obj$mean.mat)
  mean_matrix <- as.vector(t(matrices_obj$mean.mat))
  if(length(group_size)>1 | !is.integer(group_size))
  {
    stop("group_size must be a single integer")
  }
  sd_matrix <- as.vector(t(matrices_obj$sd.mat))
  if(length(group_size)==1)
  {
    fdata <- as.data.frame(mapply(rnorm, group_size, mean_matrix, sd_matrix))
    fdata$subject <- 1:group_size
    fdata <- reshape2::melt(fdata, id.vars = "subject", variable.name = "cond",
                          value.name = "y")
    for (j in 1:2)
    {
      fdata <- cbind(fdata,
                     as.factor(unlist(
                       rep(as.list(paste(names(label_list)[j], label_list[[j]], sep = "_")),
                           each = group_size * prod(factor_levels)/prod(factor_levels[1:j]),
                           times = prod(factor_levels)/prod(factor_levels[j:2])))))
    }
    names(fdata)[4:5] <- names(label_list)

    if(distribution=="normal")
    {
        y <- suppressMessages(replicate(nsims, reshape2::melt(mapply(rnorm, group_size, mean_matrix, sd_matrix))$value))
      } else if (distribution=="skewed")
    {
        y <- suppressMessages(replicate(nsims, reshape2::melt(fGarch::rsnorm(group_size*prod(factor_levels),
                          rep(mean_matrix,group_size), rep(sd_matrix,group_size),
                          xi=skewness))$value))
    }
  }
  sim <- lapply(seq(nsims),
                function(x)
                {
                  fdata$y <- y[,x]
                  fdata$iteration <- x
                  fdata
                })
  do.call(rbind, sim)
}
